<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_guy</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>map = ds_map_create();
open = ds_list_create();
openmap = ds_map_create();
closed = ds_map_create();
region_count = 0;
with(obj_terrain_parent){
  m_add(region_generator.map,id,0);
}
max_diff = 16;
in_progress = false;
checking_tiles = false;
obj = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up
ds_map_destroy(map);
ds_map_destroy(openmap);
ds_map_destroy(closed);
ds_list_destroy(open);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///generate the regions(every step shown)
/*
if(!ds_map_empty(map)){
  if(!in_progress){
  //set up for the next round
  obj = ds_map_find_first(map); //get starting point
  region_l = ds_list_create(); //create the container for the tiles
  l_add(open,obj); //put starting point in the container
  in_progress = true; 
  //else execute the next round
  }else if(!ds_list_empty(open)){
    if(!checking_tiles){
      obj = l_get(open,0); //pop out the first object in the Open Set
      l_del(open,0); //move it out of the open set
      ds_map_delete(openmap,obj);//move it out of the hash table
      m_add(closed,obj,0);  //move it into the closed set
      //check if pathable
      flag = true;
      s = ds_list_size(region_l);
      counter = 0;
      checking_tiles = true;
     }else if(counter &lt; s){
        tile = l_get(region_l,counter);
        if(!node_path_pathable(obj,tile,1)){
          flag = false;
        }
        counter += 1;
     }else{
      checking_tiles = false;
      if(flag){
        //if pathable, check its neighbors too
        l_add(region_l,obj); //put it in the region list
        ds_map_delete(map,obj); //move it out of the map
        obj.region = region_count; //set the tile to the region
        neighbors[0] = instance_position(obj.x+cell_w/2+cell_w/2,obj.y+cell_h/2+cell_h/2,obj_terrain_parent);
        neighbors[1] = instance_position(obj.x+cell_w/2+cell_w/2,obj.y+cell_h/2-cell_h/2,obj_terrain_parent);
        neighbors[2] = instance_position(obj.x+cell_w/2-cell_w/2,obj.y+cell_h/2+cell_h/2,obj_terrain_parent);
        neighbors[3] = instance_position(obj.x+cell_w/2-cell_w/2,obj.y+cell_h/2-cell_h/2,obj_terrain_parent);
        for(i=0;i&lt;4;i+=1){
          neighbor = neighbors[i];
          if(neighbor != noone){
            if (neighbor.region == noone &amp;&amp; !ds_map_exists(openmap,neighbor)){
              l_add(open,neighbor);
              m_add(openmap,neighbor,0);
            }
          }
        }
      }
    }
  }else{
    //End the round
    region = instance_create(0,0,obj_region);
    region.tile_list = region_l;
    region.region_id = region_count;
    region.initialized = true;
    region_count +=1;
    //open is already clear, by definition
    ds_map_clear(closed);
    in_progress = false;
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!ds_map_empty(map)){
  if(!in_progress){
  //set up for the next round
  obj = ds_map_find_first(map); //get starting point
  region_l = ds_list_create(); //create the container for the tiles
  l_add(open,obj); //put starting point in the container
  in_progress = true; 
  //else execute the next round
  }else if(!ds_list_empty(open)){
    obj = l_get(open,0); //pop out the first object in the Open Set
    l_del(open,0); //move it out of the open set
    ds_map_delete(openmap,obj);//move it out of the hash table
    m_add(closed,obj,0);  //move it into the closed set
    //check if pathable
    flag = true;
    s = ds_list_size(region_l);
    counter = 0;
    checking_tiles = true;
    for(counter = 0;counter&lt;s;counter+=1){
      tile = l_get(region_l,counter);
      if(!node_path_pathable(obj,tile,1)){
        flag = false;
      }
    }
    if(flag){
      //if pathable, check its neighbors too
      l_add(region_l,obj); //put it in the region list
      ds_map_delete(map,obj); //move it out of the map
      obj.region = region_count; //set the tile to the region
      neighbors[0] = instance_position(obj.x+cell_w/2+cell_w/2,obj.y+cell_h/2+cell_h/2,obj_terrain_parent);
      neighbors[1] = instance_position(obj.x+cell_w/2+cell_w/2,obj.y+cell_h/2-cell_h/2,obj_terrain_parent);
      neighbors[2] = instance_position(obj.x+cell_w/2-cell_w/2,obj.y+cell_h/2+cell_h/2,obj_terrain_parent);
      neighbors[3] = instance_position(obj.x+cell_w/2-cell_w/2,obj.y+cell_h/2-cell_h/2,obj_terrain_parent);
      for(i=0;i&lt;4;i+=1){
        neighbor = neighbors[i];
        if(neighbor != noone){
          if (neighbor.region == noone &amp;&amp; !ds_map_exists(openmap,neighbor)){
            l_add(open,neighbor);
            m_add(openmap,neighbor,0);
          }
        }
      }
    }
  }else{
    //End the round
    region = instance_create(0,0,obj_region);
    region.tile_list = region_l;
    region.region_id = region_count;
    region.initialized = true;
    region_count +=1;
    //open is already clear, by definition
    ds_map_clear(closed);
    in_progress = false;
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i,l,obj;
draw_self();
draw_set_font(font1);
draw_set_color(c_green);
if(in_progress){
  l = ds_map_size(closed);
  obj = ds_map_find_first(closed);
  for(i=0;i&lt;l;i+=1){
    draw_sprite(red,0,obj.x,obj.y);
    obj = ds_map_find_next(closed,obj);
  }
  l = ds_list_size(open);
  for(i=0;i&lt;l;i+=1){
    obj = l_get(open,i);
    draw_sprite(green,0,obj.x,obj.y);
  }
  l = ds_list_size(region_l);
  for(i=0;i&lt;l;i+=1){
    obj = l_get(region_l,i);
    draw_sprite(guyx1,0,obj.x,obj.y);
  }
}
if(checking_tiles){
  draw_text(x,y+64,string(counter));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
